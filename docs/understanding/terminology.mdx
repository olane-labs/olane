---
title: "Terminology"
description: "Essential terms and definitions for understanding Olane OS architecture and concepts"
---

## Overview

This page defines the key terms used throughout Olane OS documentation. Understanding these terms is essential for effectively building tool nodes and working with the system.

<Info>
Terms are organized by the **three-layer model**: Users (Agents) → Applications (Tool Nodes) → Operating System (Olane Runtime)
</Info>

## Core Terms

### Agent

An intelligent user that interacts with tool nodes using natural language. Agents can be either **human** or **AI-powered**.

<CardGroup cols={2}>
  <Card title="Human Agent" icon="user">
    A human user interacting via CLI, web UI, or API to express intents and receive results.
  </Card>
  
  <Card title="AI/LLM Agent" icon="robot">
    An AI agent (also called LLM agent) is a large language model (GPT-4, Claude, Gemini, etc.) that runs tools in a loop to achieve a goal.
  </Card>
</CardGroup>

**AI Agent Definition:**

An **AI agent** (or **LLM agent**) is a large language model that:
1. Receives a goal or intent
2. Decides which tools to use
3. Executes those tools
4. Evaluates results
5. Repeats the loop until the goal is achieved

AI agents can be built using frameworks like LangGraph, CrewAI, and AutoGen, or they can interact directly with Olane OS tool nodes.

**Example:**
```typescript
// Both human and AI agents use the same interface
await toolNode.use({
  method: 'intent',
  params: { intent: 'Analyze Q4 sales data' }
});
```

<Note>
**Key Point:** You don't build agents - they already exist. Humans are agents. AI models (LLMs) configured to run tools are agents. You build **tool nodes** that agents use.
</Note>

### Tool Node

A specialized application that agents use to accomplish tasks. Tool nodes accept natural language intents and process them autonomously using their domain-specific capabilities.

**Think of it as:** An application in traditional OS (like a web browser or text editor), but designed for agents instead of direct human interaction.

**Example:**
```typescript
// You build tool nodes - this is your code
class CustomerSupportTool extends oLaneTool {
  constructor() {
    super({
      address: new oAddress('o://support/customer-service'),
      description: 'Handles customer support inquiries'
    });
  }

  async _tool_lookup_customer(request) {
    // Your domain-specific business logic
    return { customer: { name: 'Alice', status: 'Premium' } };
  }
}
```

### Agent-Agnostic

Describes tool nodes that serve both human and AI agents through a unified natural language interface. The tool node doesn't need to know whether an intent came from a human or an AI.

**Benefits:**
- Build once, serve both human and AI agents
- Future-proof as AI adoption increases
- Unified interface reduces complexity

### Intent

A natural language expression of what an agent wants to accomplish. Intents are outcome-focused (what to achieve) rather than prescriptive (how to do it).

**Good Intent Examples:**
- "Analyze customer satisfaction scores from Q4 and identify improvement areas"
- "Find all pending orders and send reminder emails"
- "Generate a summary report of this week's support tickets"

**Poor Intent Examples:**
- "Do some analysis" (too vague)
- "Query database, filter results, format as JSON" (too prescriptive)

**Usage:**
```typescript
import { oIntent } from '@olane/o-lane';

const intent = new oIntent({ 
  intent: 'Calculate regional sales averages for Q4 2024' 
});
```

## Layer-Specific Terms

### Layer 1: Users

Terms related to agents and how they interact with the system.

#### Natural Language Interface

The method by which agents express their goals to tool nodes. Instead of pre-defined API calls, agents use human-readable text to describe what they want.

**Human Agent:**
```bash
olane intent "Create a customer report for the last quarter"
```

**AI Agent:**
```typescript
await toolNode.use({
  method: 'intent',
  params: { intent: 'Create a customer report for the last quarter' }
});
```

#### Agent Coordination

The process by which multiple agents (or a single agent across multiple tool nodes) work together to accomplish complex tasks.

**Example:** An AI agent coordinating between a data collection tool node, an analytics tool node, and a reporting tool node to complete a comprehensive analysis.

### Layer 2: Applications

Terms related to building and running tool nodes.

#### Tool

A discoverable method on a tool node that performs a specific operation. Tools use the `_tool_` prefix convention for automatic discovery.

**Example:**
```typescript
class AnalyticsTool extends oLaneTool {
  // This is a tool - discoverable by agents
  async _tool_calculate_revenue(request) {
    const { period } = request.params;
    // Domain logic here
    return { revenue, growth };
  }

  // Parameter schema for the tool
  _params_calculate_revenue() {
    return {
      period: { type: 'string', required: true }
    };
  }
}
```

#### Specialization

The process of making a tool node expert in a specific domain through:
1. **Context Injection** - Providing domain-specific knowledge
2. **Tool Augmentation** - Adding specialized capabilities
3. **Knowledge Accumulation** - Learning from interactions

**Key Concept:** Specialization happens through configuration and tools, NOT through training separate AI models.

#### Hierarchy

The organizational structure of tool nodes using filesystem-like paths. Child tool nodes inherit context from their parents.

**Example:**
```
o://company                        # Root - company-wide context
  ├── o://company/finance          # Inherits company context
  │   ├── o://company/finance/accounting   # + accounting context
  │   └── o://company/finance/reporting    # + reporting context
  └── o://company/engineering      # Inherits company context
      ├── o://company/engineering/backend  # + backend context
      └── o://company/engineering/frontend # + frontend context
```

#### Tool Discovery

The process by which agents find relevant tool nodes and their capabilities. Discovery happens through:
- Vector search across tool descriptions
- Registry queries
- Hierarchical exploration
- Capability indexing

### Layer 3: Operating System

Terms related to the Olane runtime infrastructure.

#### o:// Protocol

The hierarchical addressing system for tool nodes. Similar to filesystem paths or URLs, but for agent-addressable resources.

**Format:** `o://domain/subdomain/resource`

**Examples:**
- `o://company/finance/accounting`
- `o://support/customer-service`
- `o://analytics/sales`

**Features:**
- Hierarchical paths for organization
- Static and dynamic address resolution
- Content-addressable identifiers (CID)
- Automatic routing through hierarchies

#### IPC (Inter-Process Communication)

The communication mechanism between tool nodes. All IPC follows a request/response pattern using JSON-RPC 2.0.

**Example:**
```typescript
// Tool Node A communicating with Tool Node B
const response = await toolNodeA.use(
  new oAddress('o://tool-node-b'),
  {
    method: 'process_data',
    params: { data: salesData }
  }
);
```

#### Lifecycle

The states a tool node transitions through during its operation:

| State | Description |
|-------|-------------|
| `STOPPED` | Initial state, not running |
| `STARTING` | Initializing and connecting |
| `RUNNING` | Active and processing requests |
| `STOPPING` | Shutting down gracefully |
| `ERROR` | Encountered an error |

**Usage:**
```typescript
const toolNode = new MyToolNode();
await toolNode.start();  // STOPPED → STARTING → RUNNING
console.log(toolNode.state); // NodeState.RUNNING
await toolNode.stop();   // RUNNING → STOPPING → STOPPED
```

#### Router

The system that determines how to reach a target tool node from a source tool node. Routers translate o:// addresses into next-hop connections.

**Purpose:**
- Resolve hierarchical addresses
- Calculate routing paths
- Enable custom routing logic
- Support intelligent failover

## Execution Terms

### Lane

An execution context for resolving an intent. Think of it as a process in a traditional OS, but for agentic workflows.

**Properties:**
- Unique content-addressable identifier (CID)
- Lifecycle states (PENDING → RUNNING → COMPLETED)
- Complete execution history (audit trail)
- Parent-child relationships (can spawn sub-lanes)

**Example:**
```typescript
import { oLaneManager, oIntent } from '@olane/o-lane';

const manager = new oLaneManager();
const lane = await manager.createLane({
  intent: new oIntent({ intent: 'Process customer order' }),
  currentNode: myToolNode,
  caller: callerAddress
});

const result = await lane.execute();
console.log(lane.sequence); // Full execution history
```

### Capability

An atomic execution primitive that performs a specific type of action. Capabilities are the building blocks of emergent workflows.

**Built-in Capabilities:**
- `EVALUATE` - Analyze intent and decide next step
- `TASK` - Execute a specific tool method
- `SEARCH` - Query for information or tool nodes
- `CONFIGURE` - Set up environment or connections
- `ERROR` - Handle errors and attempt recovery
- `MULTIPLE_STEP` - Coordinate multi-step operations

**Custom Capability Example:**
```typescript
import { oCapability, oCapabilityResult, oCapabilityType } from '@olane/o-lane';

class EmailCapability extends oCapability {
  get type() {
    return oCapabilityType.CUSTOM;
  }

  async run(): Promise<oCapabilityResult> {
    await this.sendEmail(this.config);
    return new oCapabilityResult({
      type: oCapabilityType.EVALUATE,
      result: 'Email sent successfully'
    });
  }
}
```

### Capability Loop

The core execution pattern in o-lane where agents repeatedly evaluate, plan, and execute until the intent is resolved.

**Flow:**
```
1. EVALUATE → Agent analyzes current state
2. DECIDE   → Agent chooses next capability
3. EXECUTE  → Capability performs action
4. RECORD   → Add result to sequence
5. CHECK    → Done? If no, loop back to EVALUATE
```

**Key Properties:**
- Maximum cycles limit (default: 20)
- State accumulation (each cycle builds on previous results)
- Emergent patterns (optimal workflows discovered through execution)
- Fault tolerance (errors trigger ERROR capability)

### Execution Sequence

The chronological record of all capability executions in a lane. Provides complete audit trail and enables learning.

**Example:**
```typescript
// After lane execution
console.log(lane.sequence);
// [
//   { type: 'EVALUATE', result: { reasoning: '...', next: 'SEARCH' } },
//   { type: 'SEARCH', result: { found: 'o://analytics' } },
//   { type: 'TASK', result: { data: [...] } },
//   { type: 'STOP', result: { final: 'Success' } }
// ]
```

## Network Terms

### Leader Node

A root coordinator node that manages network-wide discovery and registration. Like the init process (PID 1) or DNS in traditional systems.

**Responsibilities:**
- Tool node registration and deregistration
- Capability indexing across the network
- Discovery queries
- Network health coordination

**Example:**
```typescript
import { oLeaderNode } from '@olane/o-leader';

const leader = new oLeaderNode({
  address: new oAddress('o://leader')
});
await leader.start();
```

### Registry

A service directory that tracks which tool nodes are available and what capabilities they provide. Enables dynamic discovery.

**Operations:**
- `commit` - Register a tool node
- `search` - Find tool nodes by criteria
- `find_all` - List all registered tool nodes
- `remove` - Deregister a tool node

**Implementations:**
- `RegistryMemoryTool` - In-memory (development/testing)
- Custom implementations (PostgreSQL, Redis, etc.)

### Peer Discovery

The process by which tool nodes find and connect to each other in a P2P network.

**Methods:**
- DHT (Distributed Hash Table)
- mDNS (Multicast DNS for local networks)
- Bootstrap nodes (known entry points)
- Leader node registration

### Network Topology

The architectural pattern of how tool nodes are organized and connected.

**Common Patterns:**

| Pattern | Description | Use Case |
|---------|-------------|----------|
| **Hub-and-Spoke** | Central leader, all tool nodes connect to it | Simple networks |
| **Hierarchical** | Department leaders under root leader | Organizational structure |
| **Multi-Leader** | Regional leaders for scale | Geographic distribution |
| **Mesh** | All tool nodes know each other | High availability |

## Architecture Terms

### Generalist-Specialist Pattern

The architectural approach where one generalist agent (LLM) serves many specialist tool nodes, rather than training separate models for each domain.

**Benefits:**
- 70-90% cost reduction vs fine-tuned models
- Single LLM brain serves all tool nodes
- Specialization through tools and context, not training

**Example:**
```
One AI Agent (GPT-4)
        ↓ uses
Multiple Specialist Tool Nodes:
  • Finance Tool Node (context + finance tools)
  • Customer Support Tool Node (context + CRM tools)
  • Analytics Tool Node (context + data tools)
```

### Emergent vs Explicit Orchestration

The fundamental difference between Olane OS and traditional workflow frameworks.

<Tabs>
  <Tab title="Explicit (Traditional)">
    **Traditional Frameworks (LangGraph):**
    - Pre-define workflow graphs
    - Explicit state machines
    - Manual step orchestration
    - Fixed execution paths
    
    ```typescript
    const workflow = new StateGraph({
      nodes: ['fetch', 'analyze', 'report'],
      edges: [['fetch', 'analyze'], ['analyze', 'report']]
    });
    ```
  </Tab>
  
  <Tab title="Emergent (Olane OS)">
    **Olane OS:**
    - Agents discover optimal workflows
    - Emergent behavior patterns
    - Capability-based autonomy
    - Dynamic path discovery
    
    ```typescript
    // Just provide the intent
    const result = await toolNode.use({
      method: 'intent',
      params: { intent: 'Analyze Q4 sales and create report' }
    });
    // Agent discovers optimal path through capabilities
    ```
  </Tab>
</Tabs>

### Context Injection

The method of providing domain-specific knowledge to tool nodes without training separate models.

**Types of Context:**
- **Conversation History** - Previous interactions
- **Domain Knowledge** - Business rules and constraints
- **Hierarchical Context** - Inherited from parent tool nodes
- **Execution History** - Learned patterns from past lanes

**Example:**
```typescript
import { oLaneContext } from '@olane/o-lane';

const context = new oLaneContext([
  '[Business Rules]',
  '- Sales reports require manager approval',
  '- All currency in USD',
  '- Redact sensitive customer data',
  '[End Rules]'
]);

const response = await toolNode.use({
  method: 'intent',
  params: {
    intent: 'Generate Q4 sales report',
    context: context.toString()
  }
});
```

### Knowledge Artifacts

Stored learnings and execution patterns that agents discover and share. Enables intelligence reuse across the system.

**How It Works:**
```
Agent A discovers: "Best way to analyze Q4 sales"
    ↓ stores knowledge artifact
o://knowledge/sales-analysis/q4-best-practices
    ↓ discovered by
Agent B: "I need to analyze sales too"
    ↓ learns from Agent A
Agent B uses proven approach (75% faster)
```

## Package Terms

### o-core

The kernel layer - abstract base classes and runtime foundation. Defines how tool nodes work without implementing transport.

**Key Classes:** `oCore`, `oAddress`, `oRouter`, `oConnection`

### o-node

Production-ready libp2p implementation of o-core. Adds real P2P networking to tool nodes.

**Key Classes:** `oNode`, `oServerNode`, `oClientNode`

### o-tool

Convention-based system for augmenting tool nodes with discoverable capabilities.

**Key Feature:** `_tool_` prefix convention for automatic tool discovery

### o-lane

Process management layer that handles intent-driven execution through capability loops.

**Key Classes:** `oLane`, `oLaneTool`, `oCapability`

### o-leader

Network coordination layer providing discovery and registration services.

**Key Classes:** `oLeaderNode`, `RegistryTool`

## Protocol Terms

### JSON-RPC 2.0

The messaging protocol used for all inter-process communication (IPC) between tool nodes.

**Request Format:**
```json
{
  "jsonrpc": "2.0",
  "method": "calculate_revenue",
  "params": { "period": "Q4" },
  "id": "request-123"
}
```

**Response Format:**
```json
{
  "jsonrpc": "2.0",
  "result": { "revenue": 1200000, "growth": 15 },
  "id": "request-123"
}
```

### Multiaddress

libp2p's addressing format that includes transport protocol and connection details.

**Example:** `/ip4/127.0.0.1/tcp/4001/p2p/QmcZf59bWwK5XFi76CZX8...`

### Peer ID

A unique identifier for a tool node in the P2P network. Derived from the node's public key.

**Properties:**
- Cryptographically secure
- Can be deterministic (from seed)
- Used for authentication and routing

## Common Abbreviations

| Term | Full Name | Description |
|------|-----------|-------------|
| **IPC** | Inter-Process Communication | Communication between tool nodes |
| **CID** | Content Identifier | Content-addressable hash identifier |
| **DHT** | Distributed Hash Table | Peer discovery mechanism |
| **P2P** | Peer-to-Peer | Networking architecture |
| **LLM** | Large Language Model | AI agent (GPT-4, Claude, etc.) |
| **mDNS** | Multicast DNS | Local network discovery |
| **NAT** | Network Address Translation | Network traversal technique |

## Usage Examples

### Complete Flow with Terminology

```typescript
// 1. Create a tool node (Application Layer)
class SalesTool extends oLaneTool {  // extends o-lane's tool class
  constructor() {
    super({
      address: new oAddress('o://company/sales'),  // o:// protocol address
      description: 'Sales analytics tool node'
    });
  }

  // 2. Add specialized tools (Tool augmentation)
  async _tool_analyze_revenue(request) {  // _tool_ convention
    // Domain-specific business logic (Specialization)
    return { revenue: 1200000, growth: 15 };
  }
}

// 3. Start tool node (Lifecycle management)
const toolNode = new SalesTool();
await toolNode.start();  // STOPPED → STARTING → RUNNING

// 4. Register with leader node (Network coordination)
// Happens automatically when tool node starts

// 5. Agent sends intent (Natural language interface)
const result = await toolNode.use({
  method: 'intent',  // Intent-driven execution
  params: {
    intent: 'Analyze Q4 revenue and identify growth trends'  // Intent
  }
});

// 6. Lane executes via capability loop (Emergent orchestration)
// - EVALUATE capability analyzes intent
// - TASK capability calls _tool_analyze_revenue
// - EVALUATE capability processes results
// - STOP capability returns final result

// 7. Result returned with execution sequence (Audit trail)
console.log(result.sequence);  // Execution sequence
// [
//   { type: 'EVALUATE', reasoning: '...' },
//   { type: 'TASK', result: { revenue: 1200000 } },
//   { type: 'STOP', result: 'Analysis complete' }
// ]
```

## Next Steps

Now that you understand the terminology, explore these topics:

<CardGroup cols={2}>
  <Card title="The Three-Layer Model" icon="layer-group" href="/understanding/three-layer-model">
    Deep dive into the Users → Applications → OS architecture
  </Card>
  
  <Card title="Core Concepts" icon="book" href="/concepts/architecture-overview">
    Understand how these terms work together in practice
  </Card>
  
  <Card title="Quickstart Guide" icon="rocket" href="/quickstart">
    Start building with these concepts
  </Card>
  
  <Card title="API Reference" icon="code" href="/api/overview">
    Technical documentation for all components
  </Card>
</CardGroup>

## Quick Reference

<Accordion title="Users Layer Terms">
- **Agent** - Human or AI user
- **Human Agent** - Human using CLI/web/API
- **AI Agent** - LLM (GPT-4, Claude, etc.)
- **Intent** - Natural language goal
- **Natural Language Interface** - How agents express goals
</Accordion>

<Accordion title="Applications Layer Terms">
- **Tool Node** - Application agents use
- **Tool** - Discoverable method on tool node
- **Specialization** - Making tool nodes domain-expert
- **Hierarchy** - Organizational structure
- **Context Injection** - Providing domain knowledge
</Accordion>

<Accordion title="Operating System Layer Terms">
- **o:// Protocol** - Addressing system
- **IPC** - Inter-Process Communication
- **Lifecycle** - Tool node states
- **Router** - Address resolution and routing
- **Lane** - Execution context
- **Capability** - Atomic execution primitive
</Accordion>

<Accordion title="Network Layer Terms">
- **Leader Node** - Root coordinator
- **Registry** - Service directory
- **Peer Discovery** - Finding other tool nodes
- **Network Topology** - Organizational pattern
</Accordion>

<Info>
**Bookmark this page** - You'll reference these terms frequently as you build with Olane OS.
</Info>
