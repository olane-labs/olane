---
title: "The Three-Layer Model"
description: "Deep dive into Olane OS's three-layer architecture: Users (AI Agents) â†’ Applications (Tool Nodes) â†’ Operating System (Olane Runtime)"
---

## Overview

Olane OS follows a three-layer architecture that mirrors traditional operating systems, but with a crucial difference: **AI agents are the users**.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 1: USERS (Agents)                     â”‚
â”‚  GPT-4, Claude, Gemini, etc.                     â”‚
â”‚  â€¢ Make requests in natural language             â”‚
â”‚  â€¢ Coordinate with other agents                  â”‚
â”‚  â€¢ Learn from interactions                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â¬‡ use
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 2: APPLICATIONS (Tool Nodes)              â”‚
â”‚  Domain-specific capabilities you build          â”‚
â”‚  â€¢ Process intents autonomously                  â”‚
â”‚  â€¢ Execute specialized tasks                     â”‚
â”‚  â€¢ Communicate with other tool nodes             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â¬‡ run on
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 3: OPERATING SYSTEM (Olane Runtime)       â”‚
â”‚  Infrastructure provided by Olane packages       â”‚
â”‚  â€¢ Manage tool node lifecycles                   â”‚
â”‚  â€¢ Handle inter-process communication            â”‚
â”‚  â€¢ Coordinate multi-tool-node networks           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

<Info>
**Key Insight**: Understanding this layered model is essential to building effectively on Olane OS. You work at Layer 2 (building tool nodes), while agents (human or AI) operate at Layer 1 (using your tool nodes).
</Info>

## Layer 1: Users (Agents)

### What They Are

Agents are **intelligent users** that interact with your tool nodes using natural language. They can be either **human** or **AI-powered**.

<CardGroup cols={2}>
  <Card title="Traditional OS" icon="user">
    Users: Humans clicking buttons, filling forms, navigating menus
  </Card>
  
  <Card title="Olane OS" icon="users">
    Users: Agents (human or AI) expressing intents in natural language
  </Card>
</CardGroup>

### Human Agents

**Humans as agents** interact with tool nodes through natural language interfaces:

- **CLI**: `olane intent "Analyze Q4 sales"`
- **Web UI**: Natural language input fields
- **API**: Programmatic intent submission
- **Chat interfaces**: Conversational interaction

Humans benefit from the same intent-driven execution as AI agents - they express **what** they want, not **how** to do it.

### AI Agents

**AI-powered agents** already exist as large language models:

- **GPT-4** (OpenAI)
- **Claude** (Anthropic)
- **Gemini** (Google)
- **Llama** (Meta)
- **And more...**

These models serve as **autonomous reasoning brains**. You don't train them, fine-tune them, or create them - you build tool nodes that both humans and AI agents use.

<Info>
**Key Insight**: Tool nodes are agent-agnostic. The same tool node serves both human and AI agents through a unified intent-based interface.
</Info>

### What They Do

Agents (both human and AI) interact with tool nodes by:

1. **Expressing intents** - Natural language goals they want to accomplish
2. **Making requests** - Invoking tool node capabilities via the o:// protocol
3. **Coordinating** - Working with multiple tool nodes to complete complex tasks
4. **Learning** - Discovering optimal workflows through execution (especially AI agents)

### How They Interact

Both human and AI agents use **natural language** to interact with tool nodes:

<CodeGroup>

```bash Human Agent (CLI)
# Human types natural language intent
olane intent "Find customers from California who purchased in Q4"
```

```typescript AI Agent (Programmatic)
// AI agent sends intent programmatically
const result = await toolNode.use({
  method: 'intent',
  params: {
    intent: 'Find customers from California who purchased in Q4'
  }
});
```

```typescript Traditional Approach (For Comparison)
// Traditional software: humans fill forms
<Form>
  <Input name="region" value="California" />
  <Input name="quarter" value="Q4" />
  <Button type="submit">Search Customers</Button>
</Form>
```

</CodeGroup>

**The key difference**: Agents (human or AI) express **outcomes** (what they want), not **implementation steps** (how to do it). The tool node autonomously figures out the "how".

### Agent Capabilities

<AccordionGroup>
  <Accordion title="Intent Expression" icon="message">
    Agents communicate goals in natural language:
    
    ```
    "Analyze sales trends and identify growth opportunities"
    "Create a support ticket for billing issue and notify the customer"
    "Find the most efficient route through our tool node network"
    ```
    
    They don't need to know implementation details - just what they want accomplished.
  </Accordion>
  
  <Accordion title="Tool Node Discovery" icon="magnifying-glass">
    Agents explore the o:// hierarchy to find relevant tool nodes:
    
    ```
    o://company/finance/*       â† Discovers financial tool nodes
    o://company/support/*       â† Discovers support tool nodes
    o://company/analytics/*     â† Discovers analytics tool nodes
    ```
    
    Discovery happens dynamically through registries and vector search.
  </Accordion>
  
  <Accordion title="Multi-Tool-Node Coordination" icon="diagram-project">
    Agents coordinate across multiple tool nodes automatically:
    
    ```
    Intent: "Generate monthly revenue report"
    
    Agent coordinates:
    1. o://finance/data-collector â†’ Fetch sales data
    2. o://analytics/processor â†’ Analyze trends
    3. o://reports/generator â†’ Create PDF report
    4. o://notifications/email â†’ Send to stakeholders
    ```
    
    No explicit workflow definition needed - the agent figures it out.
  </Accordion>
  
  <Accordion title="Knowledge Accumulation" icon="brain">
    Agents learn from execution history and knowledge artifacts:
    
    - Previous successful workflows
    - Tool node performance data
    - Domain knowledge from context
    - Shared learnings from other agents
    
    This enables emergent intelligence and workflow optimization over time.
  </Accordion>
</AccordionGroup>

### Example Agent Interaction

Here's what an agent interaction looks like from the agent's perspective:

```typescript
// Agent (GPT-4, Claude, etc.) interacts with a customer support tool node

// Step 1: Agent receives user request
const userRequest = "Look up customer Alice and create a support ticket";

// Step 2: Agent sends intent to tool node
const result = await use('o://support/customer-service', {
  method: 'intent',
  params: { intent: userRequest }
});

// Step 3: Tool node processes autonomously
// The agent doesn't need to know HOW the tool node works
// It just knows WHAT it can do (from tool node description)

// Step 4: Agent receives result
console.log(result);
// {
//   customer: { name: 'Alice', id: '12345' },
//   ticket: { id: 'TK-789', status: 'created' }
// }
```

<Warning>
**Important**: As a developer, you're not building agents. You're building tool nodes that agents use. Agents (human or AI) already exist - you build applications for them, just like you build web apps for human users.
</Warning>

## Layer 2: Applications (Tool Nodes)

### What They Are

Tool nodes are **specialized applications** that AI agents invoke to accomplish tasks. This is where you, the developer, work.

<CardGroup cols={2}>
  <Card title="Traditional Applications" icon="window">
    Web apps, mobile apps, desktop software that humans interact with
  </Card>
  
  <Card title="Tool Nodes" icon="cube">
    Specialized capabilities that AI agents interact with
  </Card>
</CardGroup>

### What You Build

You build tool nodes with domain-specific capabilities:

```typescript
import { oLaneTool } from '@olane/o-lane';
import { oAddress } from '@olane/o-core';

class FinancialAnalysisTool extends oLaneTool {
  constructor() {
    super({
      address: new oAddress('o://company/finance/analysis'),
      description: 'Analyzes financial data and generates insights'
    });
  }

  // Your domain expertise as tool methods
  async _tool_calculate_revenue(request) {
    const { period, region } = request.params;
    // Your business logic here
    return { revenue: 1500000, growth: 0.15 };
  }

  async _tool_forecast_trends(request) {
    const { data, horizon } = request.params;
    // Your forecasting algorithms
    return { projection: [...], confidence: 0.85 };
  }

  async _tool_identify_risks(request) {
    const { portfolio } = request.params;
    // Your risk analysis logic
    return { risks: [...], severity: 'medium' };
  }
}

// Start your tool node
const financeTool = new FinancialAnalysisTool();
await financeTool.start();
// Now agents can discover and use it via o://company/finance/analysis
```

### Tool Node Characteristics

<Steps>
  <Step title="Accept Intents">
    Tool nodes receive natural language intents from AI agents:
    
    ```typescript
    // Agent sends intent
    await toolNode.use({
      method: 'intent',
      params: {
        intent: 'Calculate Q4 revenue and forecast Q1 trends'
      }
    });
    
    // Your tool node processes autonomously:
    // 1. Calls _tool_calculate_revenue for Q4
    // 2. Calls _tool_forecast_trends for Q1
    // 3. Combines results and returns
    ```
  </Step>
  
  <Step title="Process Autonomously">
    Tool nodes use the capability loop to execute intents:
    
    ```
    Cycle 1: EVALUATE â†’ "Need to calculate revenue"
    Cycle 2: TASK â†’ Execute _tool_calculate_revenue
    Cycle 3: EVALUATE â†’ "Now forecast trends"
    Cycle 4: TASK â†’ Execute _tool_forecast_trends
    Cycle 5: EVALUATE â†’ "Complete, return results"
    Cycle 6: STOP â†’ Return to agent
    ```
    
    This happens automatically - you just provide the tools.
  </Step>
  
  <Step title="Coordinate with Others">
    Tool nodes can communicate with other tool nodes:
    
    ```typescript
    // Financial tool needs customer data
    const customerData = await this.use(
      new oAddress('o://crm/customers'),
      {
        method: 'lookup',
        params: { customerId: '12345' }
      }
    );
    
    // Then analyzes it with local capabilities
    return this.analyzeCustomerFinancials(customerData);
    ```
  </Step>
  
  <Step title="Return Results">
    Tool nodes return structured results to the requesting agent:
    
    ```typescript
    return {
      revenue: { q4: 1500000, growth: 0.15 },
      forecast: { q1: 1650000, confidence: 0.85 },
      insights: ['Strong growth in enterprise', 'SMB segment flat']
    };
    ```
  </Step>
</Steps>

### Tool Node Examples

<CodeGroup>

```typescript Financial Analysis Tool
class FinancialAnalysisTool extends oLaneTool {
  constructor() {
    super({
      address: new oAddress('o://company/finance/analysis'),
      description: 'Financial analysis and forecasting'
    });
  }

  async _tool_calculate_revenue(request) {
    // Your financial calculations
    return { revenue, breakdown, trends };
  }

  async _tool_forecast_trends(request) {
    // Your forecasting models
    return { projections, confidence };
  }
}
```

```typescript CRM Integration Tool
class CRMTool extends oLaneTool {
  constructor() {
    super({
      address: new oAddress('o://company/crm'),
      description: 'Customer relationship management'
    });
  }

  async _tool_lookup_customer(request) {
    // Query your CRM system
    return { customer: {...} };
  }

  async _tool_create_opportunity(request) {
    // Create sales opportunity
    return { opportunityId, status };
  }
}
```

```typescript Data Pipeline Tool
class DataPipelineTool extends oLaneTool {
  constructor() {
    super({
      address: new oAddress('o://company/data/pipeline'),
      description: 'ETL and data transformation'
    });
  }

  async _tool_extract(request) {
    // Extract from data sources
    return { data: [...] };
  }

  async _tool_transform(request) {
    // Transform data
    return { transformed: [...] };
  }

  async _tool_load(request) {
    // Load to destination
    return { loaded: true, count: 1000 };
  }
}
```

</CodeGroup>

### Specialization Through Tools + Context

Tool nodes become specialists through:

<CardGroup cols={2}>
  <Card title="Tool Augmentation" icon="wrench">
    Add domain-specific capabilities via `_tool_` methods
    
    ```typescript
    async _tool_analyze_sentiment(request) {
      // Your sentiment analysis logic
    }
    ```
  </Card>
  
  <Card title="Context Injection" icon="file-lines">
    Provide domain knowledge and business rules
    
    ```typescript
    context: `
      Business Rules:
      - Revenue in USD
      - Fiscal year starts in July
      - High value: >$100k
    `
    ```
  </Card>
  
  <Card title="Hierarchical Position" icon="sitemap">
    Inherit context from position in o:// hierarchy
    
    ```
    o://company/finance/analysis
    â€¢ Inherits company context
    â€¢ Inherits finance context
    â€¢ Adds analysis specialization
    ```
  </Card>
  
  <Card title="Knowledge Accumulation" icon="database">
    Learn from execution history and artifacts
    
    - Previous successful workflows
    - Performance optimizations
    - Domain patterns discovered
  </Card>
</CardGroup>

### The Development Experience

Building tool nodes feels like building APIs, but for AI agents:

```typescript
// Traditional REST API
app.post('/api/customers/lookup', (req, res) => {
  const customer = db.customers.find(req.body.customerId);
  res.json(customer);
});

// Olane OS Tool Node
class CustomerTool extends oLaneTool {
  async _tool_lookup(request) {
    const customer = await db.customers.find(request.params.customerId);
    return customer;
  }
}
```

**Key differences:**
- Tool nodes accept intents, not just structured requests
- Tool nodes can process autonomously using the capability loop
- Tool nodes communicate via o:// addresses, not HTTP URLs
- Tool nodes are discoverable by AI agents dynamically

## Layer 3: Operating System (Olane Runtime)

### What It Is

The **Olane Runtime** is the infrastructure layer that makes everything work. Like Linux or Windows, it provides the foundational services that applications (tool nodes) need.

<CardGroup cols={2}>
  <Card title="Traditional OS" icon="computer">
    **Linux/Windows provides:**
    - Process management
    - File systems
    - Networking
    - IPC mechanisms
  </Card>
  
  <Card title="Olane OS" icon="microchip">
    **Olane Runtime provides:**
    - Tool node lifecycle management
    - o:// addressing system
    - Inter-process communication
    - Network coordination
  </Card>
</CardGroup>

### Core Components

The Olane Runtime is composed of multiple packages, each providing specific OS-level functionality:

<Tabs>
  <Tab title="o-core (Kernel)">
    **The foundational layer** - defines how tool nodes work
    
    **Provides:**
    - Abstract tool node runtime
    - Lifecycle management (start/stop/states)
    - Hierarchical addressing (o:// protocol)
    - Routing abstractions
    - Inter-process communication interfaces
    
    **Think of it as:** The Linux kernel - defines the core abstractions
    
    ```typescript
    import { oCore, oAddress } from '@olane/o-core';
    
    // oCore is the base class for all tool nodes
    class MyTool extends oCore {
      // Implement abstract methods
    }
    ```
    
    ğŸ“š [Learn more about o-core](/packages/o-core)
  </Tab>
  
  <Tab title="o-node (Networking)">
    **Production networking implementation** using libp2p
    
    **Provides:**
    - Peer-to-peer communication
    - Automatic peer discovery
    - NAT traversal
    - Connection management
    - Multiple transports (TCP, WebSocket, WebRTC, QUIC)
    
    **Think of it as:** The networking stack - enables tool nodes to communicate
    
    ```typescript
    import { oServerNode } from '@olane/o-node';
    
    // oServerNode adds networking to tool nodes
    const toolNode = new oServerNode({
      address: new oAddress('o://my/tool')
    });
    ```
    
    ğŸ“š [Learn more about o-node](/packages/o-node)
  </Tab>
  
  <Tab title="o-tool (Tool System)">
    **Convention-based tool augmentation system**
    
    **Provides:**
    - Tool registration via `_tool_` prefix
    - Automatic parameter validation
    - Tool discovery and indexing
    - Built-in lifecycle tools
    
    **Think of it as:** System calls - how applications invoke OS functionality
    
    ```typescript
    import { oToolBase } from '@olane/o-tool';
    
    class MyTool extends oToolBase {
      // _tool_ prefix = executable by agents
      async _tool_my_capability(request) {
        // Your logic
      }
      
      // _params_ prefix = parameter validation
      _params_my_capability() {
        return {
          required: ['userId'],
          properties: {
            userId: { type: 'string' }
          }
        };
      }
    }
    ```
    
    ğŸ“š [Learn more about o-tool](/packages/o-tool)
  </Tab>
  
  <Tab title="o-lane (Process Manager)">
    **Agentic process management through capability loops**
    
    **Provides:**
    - Intent-driven execution
    - Capability-based loops
    - Execution tracking
    - Streaming support
    - State persistence
    
    **Think of it as:** systemd/process scheduler - manages running processes
    
    ```typescript
    import { oLaneTool } from '@olane/o-lane';
    
    // oLaneTool adds intent processing
    class MyTool extends oLaneTool {
      // Tool node can now accept intents
    }
    
    // Agent sends intent
    await myTool.use({
      method: 'intent',
      params: {
        intent: 'Your natural language goal'
      }
    });
    ```
    
    ğŸ“š [Learn more about o-lane](/packages/o-lane)
  </Tab>
  
  <Tab title="o-leader (Coordinator)">
    **Network coordination and service discovery**
    
    **Provides:**
    - Network entry point
    - Service registry
    - Capability indexing
    - Join request validation
    - Health coordination
    
    **Think of it as:** DNS/init process - bootstraps and coordinates the network
    
    ```typescript
    import { oLeaderNode } from '@olane/o-leader';
    
    // Create network coordinator
    const leader = new oLeaderNode({
      address: new oAddress('o://leader')
    });
    await leader.start();
    
    // Tool nodes register with leader
    // Agents discover tool nodes through leader
    ```
    
    ğŸ“š [Learn more about o-leader](/packages/o-leader)
  </Tab>
</Tabs>

### What the OS Does For You

<AccordionGroup>
  <Accordion title="Manages Tool Node Lifecycles" icon="arrows-spin">
    The runtime handles starting, stopping, and managing tool node processes:
    
    ```typescript
    // You write simple code
    const toolNode = new MyTool();
    await toolNode.start();
    
    // OS handles:
    // - Initialization sequences
    // - State transitions (STOPPED â†’ STARTING â†’ RUNNING)
    // - Resource allocation
    // - Health monitoring
    // - Graceful shutdown
    // - Cleanup on errors
    ```
    
    You don't manage process states manually - the OS does it for you.
  </Accordion>
  
  <Accordion title="Routes Communication (IPC)" icon="route">
    The runtime routes requests between tool nodes automatically:
    
    ```typescript
    // You just specify the target address
    const result = await this.use(
      new oAddress('o://company/finance/analysis'),
      { method: 'calculate_revenue', params: {...} }
    );
    
    // OS handles:
    // - Address resolution
    // - Next-hop calculation
    // - Connection establishment
    // - Message serialization
    // - Response deserialization
    // - Error handling
    ```
    
    No manual network programming required.
  </Accordion>
  
  <Accordion title="Discovers Tool Nodes" icon="radar">
    The runtime enables dynamic tool node discovery:
    
    ```typescript
    // Tool nodes register automatically
    await toolNode.start(); // Registers with leader
    
    // Agents discover tool nodes
    const results = await search({
      query: 'financial analysis',
      type: 'tool'
    });
    // Returns: [o://company/finance/analysis, ...]
    
    // OS handles:
    // - Registry management
    // - Capability indexing
    // - Vector search
    // - Network-wide discovery
    ```
  </Accordion>
  
  <Accordion title="Coordinates Networks" icon="diagram-project">
    The runtime coordinates multi-tool-node networks:
    
    ```typescript
    // Multiple tool nodes join network
    await toolNode1.start(); // Auto-registers
    await toolNode2.start(); // Auto-registers
    await toolNode3.start(); // Auto-registers
    
    // OS maintains:
    // - Service registry (who's available)
    // - Capability index (what they can do)
    // - Health status (are they working)
    // - Hierarchical relationships (parent-child)
    
    // Agents can discover and coordinate
    // without any configuration
    ```
  </Accordion>
  
  <Accordion title="Handles Failures" icon="shield-check">
    The runtime provides fault tolerance:
    
    ```typescript
    // If tool node crashes
    try {
      await this.use(targetAddress, request);
    } catch (error) {
      // OS automatically:
      // - Detects failure
      // - Cleans up connections
      // - Retries if appropriate
      // - Routes to backup if available
      // - Returns structured error
    }
    
    // You handle errors at business logic level
    // OS handles errors at infrastructure level
    ```
  </Accordion>
</AccordionGroup>

### The Package Stack

Tool nodes use different package combinations based on their needs:

```typescript
// Minimal (local development, no networking)
import { oCore } from '@olane/o-core';
class LocalTool extends oCore { }

// Basic networking
import { oServerNode } from '@olane/o-node';
class NetworkedTool extends oServerNode { }

// With tool capabilities
import { oNodeTool } from '@olane/o-tool';
class CapableTool extends oNodeTool { }

// Intent-driven (full stack)
import { oLaneTool } from '@olane/o-lane';
class IntelligentTool extends oLaneTool { }

// Each level adds more OS functionality
```

ğŸ“š [Learn how to choose packages](/packages/choosing-packages)

## How the Layers Interact

### Request Flow Example

Here's a complete flow showing all three layers working together:

<Steps>
  <Step title="Agent Initiates Request">
    **Layer 1: AI Agent (GPT-4)**
    
    ```
    Agent decides: "I need to analyze customer data"
    Agent discovers tool node: o://company/analytics
    Agent sends intent: "Analyze customer churn for Q4"
    ```
  </Step>
  
  <Step title="OS Routes Request">
    **Layer 3: Olane Runtime**
    
    ```
    â€¢ Resolves address: o://company/analytics
    â€¢ Calculates next hop in network
    â€¢ Establishes connection
    â€¢ Serializes and transmits request
    ```
  </Step>
  
  <Step title="Tool Node Receives Intent">
    **Layer 2: Analytics Tool Node**
    
    ```typescript
    // Tool node receives intent
    {
      method: 'intent',
      params: {
        intent: 'Analyze customer churn for Q4'
      }
    }
    ```
  </Step>
  
  <Step title="Tool Node Processes">
    **Layer 2 + Layer 3 Cooperation**
    
    ```
    Cycle 1: EVALUATE â†’ "Need customer data"
    Cycle 2: SEARCH â†’ Find o://company/crm
    Cycle 3: TASK â†’ Fetch customer data
    Cycle 4: EVALUATE â†’ "Have data, analyze"
    Cycle 5: TASK â†’ Run churn analysis
    Cycle 6: EVALUATE â†’ "Analysis complete"
    Cycle 7: STOP â†’ Return results
    ```
    
    (OS manages the capability loop, tool node provides the tools)
  </Step>
  
  <Step title="Results Return">
    **Layer 3: Olane Runtime**
    
    ```
    â€¢ Serializes results
    â€¢ Routes response back to agent
    â€¢ Cleans up connection
    â€¢ Updates metrics
    ```
  </Step>
  
  <Step title="Agent Receives Result">
    **Layer 1: AI Agent**
    
    ```
    Agent receives: {
      churnRate: 0.15,
      atRiskCustomers: 45,
      insights: [...]
    }
    
    Agent continues with broader goal
    ```
  </Step>
</Steps>

### Multi-Tool-Node Coordination

Here's how all three layers enable complex coordination:

```typescript
// Agent Goal: "Generate comprehensive customer report"

// Layer 1: Agent initiates
await coordinatorTool.use({
  method: 'intent',
  params: { intent: 'Generate comprehensive customer report' }
});

// Layer 2: Coordinator tool node processes intent
class CoordinatorTool extends oLaneTool {
  // The capability loop automatically:
  
  // Cycle 1: EVALUATE â†’ "Need customer data"
  // Cycle 2: SEARCH â†’ Discovers o://company/crm
  // Cycle 3: TASK â†’ Calls CRM tool
  async step1() {
    return await this.use(
      new oAddress('o://company/crm'),
      { method: 'list_customers', params: {...} }
    );
  }
  
  // Cycle 4: EVALUATE â†’ "Need financial data"
  // Cycle 5: SEARCH â†’ Discovers o://company/finance
  // Cycle 6: TASK â†’ Calls finance tool
  async step2() {
    return await this.use(
      new oAddress('o://company/finance'),
      { method: 'get_revenue', params: {...} }
    );
  }
  
  // Cycle 7: EVALUATE â†’ "Need to generate report"
  // Cycle 8: SEARCH â†’ Discovers o://company/reports
  // Cycle 9: TASK â†’ Calls report generator
  async step3() {
    return await this.use(
      new oAddress('o://company/reports'),
      { method: 'generate', params: {...} }
    );
  }
  
  // Cycle 10: STOP â†’ Return complete report
}

// Layer 3: OS handles all communication
// - Routes each request to correct tool node
// - Manages connections
// - Handles errors and retries
// - Coordinates network-wide

// Result: Agent gets comprehensive report
// without knowing the implementation details
```

## Comparing to Traditional Systems

### Traditional Three-Tier Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Presentation  â”‚ â† Web UI for humans
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Application   â”‚ â† Business logic
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Data       â”‚ â† Database
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Olane OS Three-Layer Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   AI Agents     â”‚ â† Intelligent users
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Tool Nodes    â”‚ â† Specialized capabilities
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Olane Runtime  â”‚ â† OS infrastructure
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

<Warning>
**Key Difference**: In traditional systems, presentation layer is for humans. In Olane OS, the "users" are AI agents that coordinate programmatically.
</Warning>

## What You Control at Each Layer

<CardGroup cols={3}>
  <Card title="Layer 1: Users" icon="users">
    **You DON'T control this**
    
    - Agents already exist (humans or AI models)
    - For AI: choose model (GPT-4, Claude, etc.)
    - For humans: provide interfaces (CLI, web, API)
    - You don't build or train the agents
  </Card>
  
  <Card title="Layer 2: Applications" icon="cube">
    **You BUILD this**
    
    - Define tool node capabilities
    - Implement business logic
    - Provide domain expertise
    - Configure specialization
  </Card>
  
  <Card title="Layer 3: OS" icon="microchip">
    **You CONFIGURE this**
    
    - Choose which packages
    - Set runtime options
    - Configure networking
    - Customize routing
  </Card>
</CardGroup>

## Development Workflow

Here's what development looks like across the layers:

<Steps>
  <Step title="Design Your Tool Node">
    **Layer 2 Work**
    
    - Identify domain capabilities needed
    - Design tool methods
    - Plan coordination with other tool nodes
    
    ```typescript
    // What capabilities should my tool node have?
    // - Lookup customer
    // - Create ticket
    // - Send notification
    ```
  </Step>
  
  <Step title="Choose Packages">
    **Layer 3 Configuration**
    
    - Do you need networking? â†’ o-node
    - Need tools? â†’ o-tool
    - Want intent processing? â†’ o-lane
    - Multi-tool-node network? â†’ o-leader
    
    ```typescript
    import { oLaneTool } from '@olane/o-lane';
    // Includes networking + tools + intent processing
    ```
  </Step>
  
  <Step title="Implement Tool Node">
    **Layer 2 Development**
    
    ```typescript
    class MyTool extends oLaneTool {
      constructor() {
        super({
          address: new oAddress('o://my/tool'),
          description: 'What this tool does'
        });
      }
      
      async _tool_capability1(request) {
        // Your business logic
      }
      
      async _tool_capability2(request) {
        // Your domain expertise
      }
    }
    ```
  </Step>
  
  <Step title="Start Tool Node">
    **Layer 3 Runtime**
    
    ```typescript
    const tool = new MyTool();
    await tool.start();
    // OS handles lifecycle, networking, registration
    ```
  </Step>
  
  <Step title="Test with Agent">
    **Layer 1 Interaction**
    
    ```typescript
    // Agent sends intent
    const result = await tool.use({
      method: 'intent',
      params: { intent: 'Your test goal' }
    });
    
    console.log(result);
    ```
  </Step>
</Steps>

## Key Takeaways

<CardGroup cols={2}>
  <Card title="Layer 1: Users" icon="users">
    **Agents (Human or AI)**
    
    - Already exist (humans or LLMs)
    - Use natural language intents
    - You don't build the agents
    - They use your tool nodes
  </Card>
  
  <Card title="Layer 2: Applications" icon="cube">
    **Tool Nodes**
    
    - You build these
    - Domain-specific capabilities
    - Accept intents from agents
    - This is where you code
  </Card>
  
  <Card title="Layer 3: Operating System" icon="microchip">
    **Olane Runtime**
    
    - Infrastructure packages
    - You configure, not build
    - Handles lifecycle, IPC, coordination
    - Provided by @olane/* packages
  </Card>
  
  <Card title="Your Focus" icon="bullseye">
    **Build at Layer 2**
    
    - Design tool node capabilities
    - Implement business logic
    - Leverage OS infrastructure
    - Let agents use your tools
  </Card>
</CardGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="Build Your First Tool Node" icon="rocket" href="/quickstart">
    Follow the quickstart to build a tool node in 10 minutes
  </Card>
  
  <Card title="Understand Tool Nodes" icon="cube" href="/concepts/tool-nodes/overview">
    Deep dive into building applications for AI agents
  </Card>
  
  <Card title="Choose Your Packages" icon="boxes-stacked" href="/packages/choosing-packages">
    Learn which Olane packages to use for your use case
  </Card>
  
  <Card title="See Complete Examples" icon="code" href="/examples">
    Explore full tool node implementations
  </Card>
</CardGroup>

<Info>
**Remember**: You work at Layer 2 (building tool nodes), while agents (human or AI) operate at Layer 1 (using your tool nodes), all running on Layer 3 (Olane Runtime infrastructure).
</Info>
